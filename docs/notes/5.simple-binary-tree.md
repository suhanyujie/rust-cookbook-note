# Rust 学习之基于 RefCell 的简单二叉树
>* 作者：[suhanyujie](https://github.com/suhanyujie)
>* 来源：https://github.com/suhanyujie/rust-cookbook-note
>* tags：Rust，binary-tree，Rc，RefCell
>* tips：如有不当之处，还请指正~

最近，在[力扣平台](https://leetcode-cn.com/)刷题时，无意中刷到了一个关于二叉树的题目：[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)，打算使用 Rust 实现它。

不得不承认，我的思路有些死板。当我将该题的 project 新建好后，把预备代码准备完成，我是准备先进行数据的组装，因为求二叉树的最小深度的前提是你得有一棵”树“，于是乎，参照力扣给出的节点数据结构，我开始实现”树“的加载。

```rust
// 力扣给出的节点结构
// Definition for a binary tree node.
#[derive(Debug, PartialEq, Eq)]
pub struct TreeNode {
    pub val: i32,
    pub left: Option<Rc<RefCell<TreeNode>>>,
    pub right: Option<Rc<RefCell<TreeNode>>>,
}

impl TreeNode {
    #[inline]
    pub fn new(val: i32) -> Self {
        TreeNode {
            val,
            left: None,
            right: None,
        }
    }
}
use std::cell::RefCell;
use std::rc::Rc;

struct Solution {}
impl Solution {
    pub fn min_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {}
}
```

可以看出，实际上存储时的节点结构是 `Option<Rc<RefCell<TreeNode>>>`。其中的 [Rc](https://doc.rust-lang.org/book/ch15-04-rc.html) 和 [RefCell](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html) 是 Rust 中的[智能指针](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)。

Rc 是引用计数指针，通过 clone 的方式可以被多个变量拥有对应的引用所有权，如此导致的是存储于 Rc 指针中的值是不可变的。如果我们要将值存储到其中，如何做到呢？答案就是使用内部可变的 RefCell 指针。

## 二叉树的生成
上面提到的“树”的加载，其实就是指生成二叉树的过程。简单起见，我们以力扣中给定的示例数据为例，使用数字作为二叉树的值。给定一个数组作为数节点的值：`[3, 9, 20, 15, 7]`，生成一个树前，先明确以下 2 点：

* 1.确定一个根节点，如果为空，则实例化一个节点作为树的根节点 root
* 2.后续所有节点的插入，都以根节点 root 作为起始入口

与此同时，明确二叉树的性质：

* 1.二叉树中，第 i 层最多有 2^(i-1) 个结点
* 2.如果二叉树的深度为 K，那么此二叉树最多有 2^K - 1 个结点。
* 3.二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。




