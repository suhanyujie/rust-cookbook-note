# Rust 学习之基于 RefCell 的简单二叉树
>* 作者：[suhanyujie](https://github.com/suhanyujie)
>* 来源：https://github.com/suhanyujie/rust-cookbook-note
>* tags：Rust，binary-tree，Rc，RefCell
>* tips：如有不当之处，还请指正~

最近，在[力扣平台](https://leetcode-cn.com/)刷题时，无意中刷到了一个关于二叉树的题目：[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)，打算使用 Rust 实现它。

不得不承认，我的思路有些死板。当我将该题的 project 新建好后，把预备代码准备完成，我是准备先进行数据的组装，因为求二叉树的最小深度的前提是你得有一棵”树“，于是乎，参照“力扣”给出的节点数据结构，我开始实现”树“的加载。

```rust
// 力扣给出的节点结构
// Definition for a binary tree node.
#[derive(Debug, PartialEq, Eq)]
pub struct TreeNode {
    pub val: i32,
    pub left: Option<Rc<RefCell<TreeNode>>>,
    pub right: Option<Rc<RefCell<TreeNode>>>,
}

impl TreeNode {
    #[inline]
    pub fn new(val: i32) -> Self {
        TreeNode {
            val,
            left: None,
            right: None,
        }
    }
}
use std::cell::RefCell;
use std::rc::Rc;

struct Solution {}
impl Solution {
    pub fn min_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        
    }
}
```

在实现 min_depth 之前，我打算先实现树的生成。

可以看出，实际上存储时的节点结构是 `Option<Rc<RefCell<TreeNode>>>`。其中的 [Rc](https://doc.rust-lang.org/book/ch15-04-rc.html) 和 [RefCell](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html) 是 Rust 中的[智能指针](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)。

Rc 是引用计数指针，通过 clone 的方式可以被多个变量拥有对应的引用所有权，如此导致的是存储于 Rc 指针中的值是不可变的。如果我们要将值存储到其中，如何做到呢？答案就是使用内部可变的 RefCell 指针。

## 准备工作

在开始写代码之前，我们先用 cargo 创建一个项目：

```
// 假设我们的项目目录名称是 _111_minimum-depth-of-binary-tree
cargo new --lib _111_minimum-depth-of-binary-tree
cd _111_minimum-depth-of-binary-tree
```

此时 cargo 为你的项目生成了如下的目录结构：

```
├── Cargo.lock
├── Cargo.toml
└── src
    └── lib.rs
```

由于只是个比较小的代码库，因此具体的代码实现可以直接写在 lib.rs 文件中。

## 二叉树的生成
上面提到的“树”的加载，其实就是指生成二叉树的过程。简单起见，我们以力扣中给定的示例数据为例，使用数字作为二叉树的值。给定一个数组作为数节点的值：`[3, 9, 20, 15, 7]`，生成一个树前，先明确以下 2 点：

* 1.确定一个根节点，如果为空，则实例化一个节点作为树的根节点 root
* 2.后续所有节点的插入，都以根节点 root 作为起始入口

生成一棵树，我们先假设只有一个节点，入参是 `[3]`。我们可以通过 TreeNode 的 new 函数实例化一个节点：

```rust
let node = TreeNode::new(3);
let root_op: Option<Rc<RefCell<TreeNode>>> = Some(Rc::new(RefCell::new(node)));
```

这只是简单的将一个值包装成根节点，实际情况下，我们会将一批数据加入到树中，从而生成“茂盛”的树状结构。为此，我们一步一步来，先声明一个 `TreeTrait` trait，其中我们会声明一些抽象方法，用于树的初始化、节点的新增、删除等：

```rust
trait TreeTrait {
    // 实例化一棵树
    fn new(self: &mut Tree, value: i32) -> Option<Rc<RefCell<TreeNode>>>;

    // 插入
    fn insert(self: &mut Self, value: i32) -> Option<Rc<RefCell<TreeNode>>>;
    
    // 删除
    fn delete(self: &mut Self, value: i32) -> Result<i32, String>;
}
```

然后，我们需要声明一个树的结构 `Tree`，并为它实现 `TreeTrait` trait：

```rust
#[derive(Debug)]
struct Tree {
    root: TreeNode,
    length: u32,
}

impl TreeTrait for Tree {
    fn new(self: &mut Tree, value: i32) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()
    }
    fn insert(self: &mut Tree, value: i32) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()
    }
    fn delete(self: &mut Self, value: i32) -> Result<i32, String> {
        todo!()
    }
}
```

### 树的实例化
我们通过集成的测试用例来对功能进行测试：

```rust
#[test]
fn test_tree_new() {
    let tree = Tree::new(3);
    let v1 = tree.root.unwrap().borrow().val;

    assert_eq!(v1, 3);
}
```

### 新增节点
### 删除节点

我们需要实现一个方法 load_tree，可以遍历数组中所有的元素，将其实例化成节点，加入到树中：

```rust

```

我们把所有的节点都包装成 `Option<Rc<RefCell<TreeNode>>>` 结构，并写出对应的单元测试：

```

```





与此同时，明确二叉树的性质：

* 1.二叉树中，第 i 层最多有 2^(i-1) 个结点
* 2.如果二叉树的深度为 K，那么此二叉树最多有 2^K - 1 个结点。
* 3.二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。



## reference
* Rust 官方书 https://doc.rust-lang.org/book
* Rust 官方书中文 https://kaisery.github.io/trpl-zh-cn/ch15-05-interior-mutability.html
* 二叉树 http://data.biancheng.net/view/192.html
